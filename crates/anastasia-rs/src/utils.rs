use std::sync::LazyLock;

use ark_bn254::Fr;
use ark_crypto_primitives::{crh::CRHScheme, sponge::poseidon::PoseidonConfig};
use ark_ff::{AdditiveGroup, BigInteger, PrimeField};
use base64::{Engine as _, engine::general_purpose::URL_SAFE_NO_PAD};

use crate::poseidon::{CRH, get_poseidon_parameters_2};

pub static POSEIDON_CONFIG_2: LazyLock<PoseidonConfig<Fr>> =
    LazyLock::new(|| get_poseidon_parameters_2());

pub fn field_to_base64url(v: &Fr) -> String {
    let bytes = v.into_bigint().to_bytes_be();
    URL_SAFE_NO_PAD.encode(bytes)
}

pub fn base64url_to_field(s: &str) -> Result<Fr, String> {
    let bytes = URL_SAFE_NO_PAD
        .decode(s)
        .map_err(|_| "Failed to decode base64url string".to_string())?;
    if bytes.len() != 32 {
        return Err("Decoded bytes must be 32 bytes".to_string());
    }
    Ok(Fr::from_be_bytes_mod_order(&bytes))
}

#[derive(Debug, Clone, Copy)]
pub struct UtcTime {
    pub year: u16,
    pub month: u8,
    pub day: u8,
    pub hour: u8,
    pub minute: u8,
    pub second: u8,
}

impl UtcTime {
    pub fn to_bytes(&self) -> [u8; 7] {
        let mut bytes = [0u8; 7];
        bytes[0..2].copy_from_slice(&self.year.to_be_bytes());
        bytes[2] = self.month;
        bytes[3] = self.day;
        bytes[4] = self.hour;
        bytes[5] = self.minute;
        bytes[6] = self.second;
        bytes
    }
}

pub fn to_fixed_array<const N: usize>(src: &[u8]) -> Result<[u8; N], String> {
    if src.len() > N {
        return Err(format!("input length {} exceeds {} bytes", src.len(), N));
    }
    let mut buf = [0u8; N];
    buf[..src.len()].copy_from_slice(src);
    Ok(buf)
}

pub fn commit_attrs(
    dn: [u8; 124],
    key_identifier: [u8; 20],
    pk_x: [u8; 32],
    pk_y: [u8; 32],
    r: Fr,
) -> Result<Fr, String> {
    let mut state = Fr::ZERO;
    let mut slice = [0u8; 31];

    for j in 0..31 {
        slice[j] = dn[j];
    }
    state = Fr::from_le_bytes_mod_order(&slice);

    for i in 1..4 {
        for j in 0..31 {
            slice[j] = dn[i * 31 + j];
        }
        state = CRH::<Fr>::evaluate(
            &*POSEIDON_CONFIG_2,
            [state, Fr::from_le_bytes_mod_order(&slice)],
        )
        .map_err(|e| format!("Poseidon CRH error: {}", e))?;
    }

    for j in 0..20 {
        slice[j] = key_identifier[j];
    }
    for j in 20..31 {
        slice[j] = pk_x[j - 20];
    }
    state = CRH::<Fr>::evaluate(
        &*POSEIDON_CONFIG_2,
        [state, Fr::from_le_bytes_mod_order(&slice)],
    )
    .map_err(|e| format!("Poseidon CRH error: {}", e))?;

    for j in 0..21 {
        slice[j] = pk_x[11 + j];
    }
    for j in 21..31 {
        slice[j] = pk_y[j - 21];
    }
    state = CRH::<Fr>::evaluate(
        &*POSEIDON_CONFIG_2,
        [state, Fr::from_le_bytes_mod_order(&slice)],
    )
    .map_err(|e| format!("Poseidon CRH error: {}", e))?;

    slice = [0; 31];
    for j in 0..22 {
        slice[j] = pk_y[10 + j];
    }
    state = CRH::<Fr>::evaluate(
        &*POSEIDON_CONFIG_2,
        [state, Fr::from_le_bytes_mod_order(&slice)],
    )
    .map_err(|e| format!("Poseidon CRH error: {}", e))?;

    state = CRH::<Fr>::evaluate(&*POSEIDON_CONFIG_2, [state, r])
        .map_err(|e| format!("Poseidon CRH error: {}", e))?;

    Ok(state)
}

pub fn from_u8_array_to_fr_vec(u8_array: &[u8]) -> Vec<Fr> {
    u8_array.iter().map(|b| Fr::from(*b as u64)).collect()
}

#[cfg(test)]
mod tests {
    use ark_ff::BigInteger;

    use super::*;

    #[test]
    fn test_to_fixed_array() {
        let src = vec![1, 2, 3, 4, 5];
        let arr: [u8; 10] = to_fixed_array(&src).unwrap();
        assert_eq!(&arr[..5], &src[..]);
        assert_eq!(&arr[5..], &[0; 5]);
    }

    #[test]
    fn test_commit_attrs() {
        let dn = [
            0x30, 0x29, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0a, 0x47,
            0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x20, 0x4c, 0x4c, 0x43, 0x31, 0x12, 0x30, 0x10, 0x06,
            0x03, 0x55, 0x04, 0x03, 0x13, 0x09, 0x44, 0x72, 0x6f, 0x69, 0x64, 0x20, 0x43, 0x41,
            0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];
        let key_identifier = [
            0xfe, 0x62, 0x6c, 0xdc, 0x2a, 0xe5, 0x80, 0xe7, 0x19, 0x6a, 0xca, 0x23, 0xdd, 0x23,
            0xf1, 0x39, 0x02, 0x46, 0xa8, 0xa5,
        ];
        let pk_x = [
            0x29, 0xc2, 0xef, 0x24, 0xa4, 0xbe, 0x89, 0xfd, 0x51, 0x35, 0x89, 0x24, 0xb3, 0x2e,
            0x38, 0xd2, 0x5b, 0x64, 0x9e, 0x4e, 0x96, 0xff, 0x0b, 0x6f, 0x6b, 0xe2, 0x12, 0x87,
            0x1b, 0xf5, 0x26, 0x27,
        ];
        let pk_y = [
            0x9a, 0x9d, 0x6b, 0x56, 0x68, 0x29, 0xbf, 0x3a, 0xf8, 0xfe, 0xe0, 0x50, 0x94, 0x3f,
            0xbb, 0x70, 0xab, 0xf5, 0xb1, 0xb3, 0x5a, 0xc1, 0xe3, 0xb8, 0x95, 0xee, 0x2e, 0xc0,
            0xa8, 0x5a, 0xfb, 0xd2,
        ];
        let r = Fr::from(0xdeadbeefu64);

        let cmt = commit_attrs(dn, key_identifier, pk_x, pk_y, r);
        assert!(cmt.is_ok());
        let cmt_bytes = cmt.unwrap().into_bigint().to_bytes_be();
        let cmt_hex = hex::encode(cmt_bytes);
        assert_eq!(
            cmt_hex,
            "0ede28f511104f08069e07986707873be5cbba917f02f02407ad1fdd6838679b"
        );
    }

    #[test]
    fn test_commit_attrs_2() {
        let dn = [
            0x30, 0x3f, 0x31, 0x29, 0x30, 0x27, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x20, 0x65,
            0x35, 0x62, 0x66, 0x61, 0x39, 0x37, 0x37, 0x31, 0x35, 0x63, 0x31, 0x63, 0x62, 0x31,
            0x31, 0x37, 0x30, 0x63, 0x33, 0x30, 0x65, 0x30, 0x31, 0x33, 0x33, 0x31, 0x65, 0x65,
            0x66, 0x34, 0x32, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x09,
            0x53, 0x74, 0x72, 0x6f, 0x6e, 0x67, 0x42, 0x6f, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];
        let key_identifier = [
            0x83, 0x29, 0xbe, 0xbb, 0x68, 0xbc, 0x24, 0xed, 0x89, 0x38, 0x4d, 0xb4, 0xf1, 0x94,
            0x6c, 0x20, 0xd7, 0x95, 0x9a, 0x05,
        ];
        let pk_x = [
            0xa3, 0x30, 0xd2, 0x88, 0x45, 0xc2, 0xf4, 0xb1, 0x60, 0xa7, 0xa5, 0xa8, 0xec, 0x1e,
            0x46, 0x21, 0x31, 0x18, 0x5e, 0x25, 0xba, 0x48, 0x7e, 0xba, 0x2f, 0xbb, 0x41, 0xd7,
            0x18, 0xa7, 0xa6, 0xbf,
        ];
        let pk_y = [
            0xd7, 0x87, 0x8d, 0xc6, 0x36, 0xe4, 0x1e, 0xa4, 0xe2, 0x51, 0x6a, 0xa9, 0xc4, 0xf7,
            0x1f, 0xce, 0x15, 0xf5, 0xd2, 0x48, 0x34, 0x05, 0x82, 0x56, 0x99, 0x72, 0x5c, 0xb1,
            0x3c, 0xeb, 0x47, 0xcd,
        ];
        let r = Fr::from(0xfeedfaceu64);

        let cmt = commit_attrs(dn, key_identifier, pk_x, pk_y, r);
        assert!(cmt.is_ok());
        let cmt_bytes = cmt.unwrap().into_bigint().to_bytes_be();
        let cmt_hex = hex::encode(cmt_bytes);
        assert_eq!(
            cmt_hex,
            "2a296b0c9a2c8b4c6c56357c632860849f42a4defa6b491b2421a962a3543f5c"
        );
    }
}
